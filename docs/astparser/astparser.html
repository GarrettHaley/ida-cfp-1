<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.5.3" />
<title>astparser..astparser API documentation</title>
<meta name="description" content="Defines `AstParser` â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.name small{font-weight:normal}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title"><code>astparser..astparser</code> module</h1>
</header>
<section id="section-intro">
<p>Defines <a title="astparser..astparser.AstParser" href="#astparser..astparser.AstParser"><code>AstParser</code></a>.</p>
<p>Instantiates the module-level logger with the appropriate naming
convention.</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">&#34;&#34;&#34;
Defines `AstParser`.

Instantiates the module-level logger with the appropriate naming
convention.
&#34;&#34;&#34;

import logging
from abc import ABC
import sys
from pycparser import c_ast

from verifier.verifier import Verifier
from record.record import Record
from exception.exception import AstEmptyError

LOGGER = logging.getLogger(__name__)


class AstParser(ABC):
    &#34;&#34;&#34;
    Define the object responsible for navigating and processing ASTs.

    `AstParser` provides a traversal system interface compatible with
    a top-level AST or an arbitrary per-node `c_ast.NodeVisitor`.

    A fully parsed AST object averages between 30 and 50 bytes. Anything
    less than the `MIN_BYTES` class variable can be an indication of a
    more serious problem.
    &#34;&#34;&#34;

    MIN_BYTES = 10

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;
        Initialize the `AstParser` object.

        The internal state of the `ConstantVisitor` and `FuncDefVisitor`
        is not persisted between parsed files as __init__ is called.

        :return: returns nothing
        &#34;&#34;&#34;
        self.const_visitor = ConstantVisitor()
        self.func_visitor = FuncDefVisitor()

    def process_ast(self, ast) -&gt; None:
        &#34;&#34;&#34;
        Process an AST by node using custom derived `Visitor`s.

        Properly processing and internalizing an AST for the purposes
        of discovering all unique strings, and which functions are
        responsible for handling those strings consists of two distinct
        parts: find the functions, find the strings within those
        functions.

        For the above process, this function serves only as the moderator.

        :param ast: top-level AST generated as a result of parse_file
        :return: returns nothing
        &#34;&#34;&#34;
        # Unless the file is blank, there will always be a generated
        # AST. Any result otherwise is a critical error
        if sys.getsizeof(ast) &lt; AstParser.MIN_BYTES:
            raise AstEmptyError()

        self.build_function_str_pairs(ast)

        # Opposite of the size check above, finding no strings within an
        # AST is perfectly reasonable, however it can be cause for concern
        if not Record.tpl_list:
            LOGGER.warning(&#34;No strings found in target file&#34;)

    def build_function_str_pairs(self, ast) -&gt; None:
        &#34;&#34;&#34;
        Construct a list of tuples of functions: strings for an AST.

        Before adding anything to the master `Record` list of tuples
        the entire AST has to be traversed and any `FuncDef` nodes
        captured. Then, iterating each node and recursively searching
        for constants (strings) results in a list of all strings used
        by that function.

        Every string, regardless of its status as unique is added to the
        list of tuples. Uniqueness only becomes a factor once all files
        have been parsed and its time to add things to the final
        dictionary.

        :param ast: top-level AST generated as a result of parse_file
        :return: returns nothing
        &#34;&#34;&#34;
        function_list = self.locate_functions(ast)
        function_strings = []

        for function_node in function_list:

            # Explicitly clearing the list of strings using clear() is
            # unfortunately the most elegant way to ensure that no
            # strings from the last function_node persist to the second
            function_strings.clear()
            function_strings = self.locate_func_strings(function_node)

            for function_str in function_strings:
                Record.add_func_str_to_list(function_node.decl.name,
                                            function_str)

        # While dictionaries are not inherently sortable, they do preserve
        # their insertion order. Thus, keeping the list of tuples pre-sorted
        # ensures that the final dictionary is at least somewhat in order
        Record.sort_tmp_list()

        # Clear all of the nodes and values for the ConstantVisitor
        # and FuncDefVisitor instances
        self.__init__()

    def locate_functions(self, ast) -&gt; list:
        &#34;&#34;&#34;
        Locate all function definitions within an AST.

        Utilizes the `FuncDefVisitor`, which is derived from the
        `NodeVisitor` base class that is responsible for visiting c_ast
        nodes. Additional details can be found under the `FuncDefVisitor`
        class definition.

        :param ast: top-level AST generated as a result of parse_file
        :return self.func_visitor.nodes: list of all c_ast function nodes
        &#34;&#34;&#34;
        # Calls the `NodeVisitor` base class&#39; visit(), which constructs the
        # custom `FuncDef` visit() function
        self.func_visitor.visit(ast)

        # Log each function names
        Verifier.check_num_ast_functions(self.func_visitor.nodes)

        return self.func_visitor.nodes

    def locate_func_strings(self, node) -&gt; list:
        &#34;&#34;&#34;
        Locate all strings used within a function&#39;s definition.

        Searches, without diving (non-recursive) below, all of the constants
        found within a mini-AST or function node AST. Constants which are
        not strings are stripped by the `ConstantVisitor`.

        :param node: `FuncDef` node
        :return self.const_visitor.values: list of all strings a function uses
        &#34;&#34;&#34;
        self.const_visitor.visit(node)
        return self.const_visitor.values


class ConstantVisitor(c_ast.NodeVisitor):
    &#34;&#34;&#34;
    Define the object responsible for locating constants in ASTs.

    `ConstantVisitor` is the example derived `NodeVisitor` described
    in the PycParser documentation at L:109
    https://github.com/eliben/pycparser/blob/master/pycparser/c_ast.py
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;
        Initialize the `ConstantVisitor` object.

        :return: returns nothing
        &#34;&#34;&#34;
        self.values = []

    def visit_Constant(self, node) -&gt; None:
        &#34;&#34;&#34;
        Create a list of values of the constant nodes encountered.

        Does not traverse the children of nodes for which this function
        was defined. To do that, call the base `NodeVisitor` member
        function generic_visit() on the target node.

        :param node: AST `FuncDef` node
        :return: returns nothing
        &#34;&#34;&#34;
        try:
            # Ints are not captured as unique identifiers in IDA-CFP
            # and thus must be removed from the list of potential
            # unique constants
            int(node.value)

        except ValueError:
            # When strings are found by traversal they are wrapped in an
            # extra set of double quotes.
            stripped = node.value.replace(&#39;&#34;&#39;, &#39;&#39;)
            if stripped:
                self.values.append(stripped)


class FuncDefVisitor(c_ast.NodeVisitor):
    &#34;&#34;&#34;
    Define the object responsible for locating function definitions in ASTs.

    `FuncDefVisitor` is the example derived `NodeVisitor` described
    in the PycParser documentation at L:25
    https://github.com/eliben/pycparser/blob/master/examples/func_defs.py
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;
        Initialize the `FuncDefVisitor` object.

        :return: returns nothing
        &#34;&#34;&#34;
        self.nodes = []

    def visit_FuncDef(self, node) -&gt; None:
        &#34;&#34;&#34;
        Create a list of `FuncDef` nodes encountered.

        Does not traverse the children of nodes for which this function
        was defined. To do that, call the base `NodeVisitor` member
        function generic_visit() on the target node.

        :param node: top-level AST generated as a result of parse_file
        :return: returns nothing
        &#34;&#34;&#34;
        self.nodes.append(node)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="astparser..astparser.AstParser"><code class="flex name class">
<span>class <span class="ident">AstParser</span></span>
<span>(</span><span><small>ancestors:</small> abc.ABC)</span>
</code></dt>
<dd>
<section class="desc"><p>Define the object responsible for navigating and processing ASTs.</p>
<p><a title="astparser..astparser.AstParser" href="#astparser..astparser.AstParser"><code>AstParser</code></a> provides a traversal system interface compatible with
a top-level AST or an arbitrary per-node <code>c_ast.NodeVisitor</code>.</p>
<p>A fully parsed AST object averages between 30 and 50 bytes. Anything
less than the <code>MIN_BYTES</code> class variable can be an indication of a
more serious problem.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class AstParser(ABC):
    &#34;&#34;&#34;
    Define the object responsible for navigating and processing ASTs.

    `AstParser` provides a traversal system interface compatible with
    a top-level AST or an arbitrary per-node `c_ast.NodeVisitor`.

    A fully parsed AST object averages between 30 and 50 bytes. Anything
    less than the `MIN_BYTES` class variable can be an indication of a
    more serious problem.
    &#34;&#34;&#34;

    MIN_BYTES = 10

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;
        Initialize the `AstParser` object.

        The internal state of the `ConstantVisitor` and `FuncDefVisitor`
        is not persisted between parsed files as __init__ is called.

        :return: returns nothing
        &#34;&#34;&#34;
        self.const_visitor = ConstantVisitor()
        self.func_visitor = FuncDefVisitor()

    def process_ast(self, ast) -&gt; None:
        &#34;&#34;&#34;
        Process an AST by node using custom derived `Visitor`s.

        Properly processing and internalizing an AST for the purposes
        of discovering all unique strings, and which functions are
        responsible for handling those strings consists of two distinct
        parts: find the functions, find the strings within those
        functions.

        For the above process, this function serves only as the moderator.

        :param ast: top-level AST generated as a result of parse_file
        :return: returns nothing
        &#34;&#34;&#34;
        # Unless the file is blank, there will always be a generated
        # AST. Any result otherwise is a critical error
        if sys.getsizeof(ast) &lt; AstParser.MIN_BYTES:
            raise AstEmptyError()

        self.build_function_str_pairs(ast)

        # Opposite of the size check above, finding no strings within an
        # AST is perfectly reasonable, however it can be cause for concern
        if not Record.tpl_list:
            LOGGER.warning(&#34;No strings found in target file&#34;)

    def build_function_str_pairs(self, ast) -&gt; None:
        &#34;&#34;&#34;
        Construct a list of tuples of functions: strings for an AST.

        Before adding anything to the master `Record` list of tuples
        the entire AST has to be traversed and any `FuncDef` nodes
        captured. Then, iterating each node and recursively searching
        for constants (strings) results in a list of all strings used
        by that function.

        Every string, regardless of its status as unique is added to the
        list of tuples. Uniqueness only becomes a factor once all files
        have been parsed and its time to add things to the final
        dictionary.

        :param ast: top-level AST generated as a result of parse_file
        :return: returns nothing
        &#34;&#34;&#34;
        function_list = self.locate_functions(ast)
        function_strings = []

        for function_node in function_list:

            # Explicitly clearing the list of strings using clear() is
            # unfortunately the most elegant way to ensure that no
            # strings from the last function_node persist to the second
            function_strings.clear()
            function_strings = self.locate_func_strings(function_node)

            for function_str in function_strings:
                Record.add_func_str_to_list(function_node.decl.name,
                                            function_str)

        # While dictionaries are not inherently sortable, they do preserve
        # their insertion order. Thus, keeping the list of tuples pre-sorted
        # ensures that the final dictionary is at least somewhat in order
        Record.sort_tmp_list()

        # Clear all of the nodes and values for the ConstantVisitor
        # and FuncDefVisitor instances
        self.__init__()

    def locate_functions(self, ast) -&gt; list:
        &#34;&#34;&#34;
        Locate all function definitions within an AST.

        Utilizes the `FuncDefVisitor`, which is derived from the
        `NodeVisitor` base class that is responsible for visiting c_ast
        nodes. Additional details can be found under the `FuncDefVisitor`
        class definition.

        :param ast: top-level AST generated as a result of parse_file
        :return self.func_visitor.nodes: list of all c_ast function nodes
        &#34;&#34;&#34;
        # Calls the `NodeVisitor` base class&#39; visit(), which constructs the
        # custom `FuncDef` visit() function
        self.func_visitor.visit(ast)

        # Log each function names
        Verifier.check_num_ast_functions(self.func_visitor.nodes)

        return self.func_visitor.nodes

    def locate_func_strings(self, node) -&gt; list:
        &#34;&#34;&#34;
        Locate all strings used within a function&#39;s definition.

        Searches, without diving (non-recursive) below, all of the constants
        found within a mini-AST or function node AST. Constants which are
        not strings are stripped by the `ConstantVisitor`.

        :param node: `FuncDef` node
        :return self.const_visitor.values: list of all strings a function uses
        &#34;&#34;&#34;
        self.const_visitor.visit(node)
        return self.const_visitor.values</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="astparser..astparser.AstParser.MIN_BYTES"><code class="name">var <span class="ident">MIN_BYTES</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="astparser..astparser.AstParser.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Initialize the <a title="astparser..astparser.AstParser" href="#astparser..astparser.AstParser"><code>AstParser</code></a> object.</p>
<p>The internal state of the <a title="astparser..astparser.ConstantVisitor" href="#astparser..astparser.ConstantVisitor"><code>ConstantVisitor</code></a> and <a title="astparser..astparser.FuncDefVisitor" href="#astparser..astparser.FuncDefVisitor"><code>FuncDefVisitor</code></a>
is not persisted between parsed files as <strong>init</strong> is called.</p>
<p>:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def __init__(self) -&gt; None:
    &#34;&#34;&#34;
    Initialize the `AstParser` object.

    The internal state of the `ConstantVisitor` and `FuncDefVisitor`
    is not persisted between parsed files as __init__ is called.

    :return: returns nothing
    &#34;&#34;&#34;
    self.const_visitor = ConstantVisitor()
    self.func_visitor = FuncDefVisitor()</code></pre>
</details>
</dd>
<dt id="astparser..astparser.AstParser.build_function_str_pairs"><code class="name flex">
<span>def <span class="ident">build_function_str_pairs</span></span>(<span>self, ast)</span>
</code></dt>
<dd>
<section class="desc"><p>Construct a list of tuples of functions: strings for an AST.</p>
<p>Before adding anything to the master <code>Record</code> list of tuples
the entire AST has to be traversed and any <code>FuncDef</code> nodes
captured. Then, iterating each node and recursively searching
for constants (strings) results in a list of all strings used
by that function.</p>
<p>Every string, regardless of its status as unique is added to the
list of tuples. Uniqueness only becomes a factor once all files
have been parsed and its time to add things to the final
dictionary.</p>
<p>:param ast: top-level AST generated as a result of parse_file
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def build_function_str_pairs(self, ast) -&gt; None:
    &#34;&#34;&#34;
    Construct a list of tuples of functions: strings for an AST.

    Before adding anything to the master `Record` list of tuples
    the entire AST has to be traversed and any `FuncDef` nodes
    captured. Then, iterating each node and recursively searching
    for constants (strings) results in a list of all strings used
    by that function.

    Every string, regardless of its status as unique is added to the
    list of tuples. Uniqueness only becomes a factor once all files
    have been parsed and its time to add things to the final
    dictionary.

    :param ast: top-level AST generated as a result of parse_file
    :return: returns nothing
    &#34;&#34;&#34;
    function_list = self.locate_functions(ast)
    function_strings = []

    for function_node in function_list:

        # Explicitly clearing the list of strings using clear() is
        # unfortunately the most elegant way to ensure that no
        # strings from the last function_node persist to the second
        function_strings.clear()
        function_strings = self.locate_func_strings(function_node)

        for function_str in function_strings:
            Record.add_func_str_to_list(function_node.decl.name,
                                        function_str)

    # While dictionaries are not inherently sortable, they do preserve
    # their insertion order. Thus, keeping the list of tuples pre-sorted
    # ensures that the final dictionary is at least somewhat in order
    Record.sort_tmp_list()

    # Clear all of the nodes and values for the ConstantVisitor
    # and FuncDefVisitor instances
    self.__init__()</code></pre>
</details>
</dd>
<dt id="astparser..astparser.AstParser.locate_func_strings"><code class="name flex">
<span>def <span class="ident">locate_func_strings</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<section class="desc"><p>Locate all strings used within a function's definition.</p>
<p>Searches, without diving (non-recursive) below, all of the constants
found within a mini-AST or function node AST. Constants which are
not strings are stripped by the <a title="astparser..astparser.ConstantVisitor" href="#astparser..astparser.ConstantVisitor"><code>ConstantVisitor</code></a>.</p>
<p>:param node: <code>FuncDef</code> node
:return self.const_visitor.values: list of all strings a function uses</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def locate_func_strings(self, node) -&gt; list:
    &#34;&#34;&#34;
    Locate all strings used within a function&#39;s definition.

    Searches, without diving (non-recursive) below, all of the constants
    found within a mini-AST or function node AST. Constants which are
    not strings are stripped by the `ConstantVisitor`.

    :param node: `FuncDef` node
    :return self.const_visitor.values: list of all strings a function uses
    &#34;&#34;&#34;
    self.const_visitor.visit(node)
    return self.const_visitor.values</code></pre>
</details>
</dd>
<dt id="astparser..astparser.AstParser.locate_functions"><code class="name flex">
<span>def <span class="ident">locate_functions</span></span>(<span>self, ast)</span>
</code></dt>
<dd>
<section class="desc"><p>Locate all function definitions within an AST.</p>
<p>Utilizes the <a title="astparser..astparser.FuncDefVisitor" href="#astparser..astparser.FuncDefVisitor"><code>FuncDefVisitor</code></a>, which is derived from the
<code>NodeVisitor</code> base class that is responsible for visiting c_ast
nodes. Additional details can be found under the <a title="astparser..astparser.FuncDefVisitor" href="#astparser..astparser.FuncDefVisitor"><code>FuncDefVisitor</code></a>
class definition.</p>
<p>:param ast: top-level AST generated as a result of parse_file
:return self.func_visitor.nodes: list of all c_ast function nodes</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def locate_functions(self, ast) -&gt; list:
    &#34;&#34;&#34;
    Locate all function definitions within an AST.

    Utilizes the `FuncDefVisitor`, which is derived from the
    `NodeVisitor` base class that is responsible for visiting c_ast
    nodes. Additional details can be found under the `FuncDefVisitor`
    class definition.

    :param ast: top-level AST generated as a result of parse_file
    :return self.func_visitor.nodes: list of all c_ast function nodes
    &#34;&#34;&#34;
    # Calls the `NodeVisitor` base class&#39; visit(), which constructs the
    # custom `FuncDef` visit() function
    self.func_visitor.visit(ast)

    # Log each function names
    Verifier.check_num_ast_functions(self.func_visitor.nodes)

    return self.func_visitor.nodes</code></pre>
</details>
</dd>
<dt id="astparser..astparser.AstParser.process_ast"><code class="name flex">
<span>def <span class="ident">process_ast</span></span>(<span>self, ast)</span>
</code></dt>
<dd>
<section class="desc"><p>Process an AST by node using custom derived <code>Visitor</code>s.</p>
<dl>
<dt>Properly processing and internalizing an AST for the purposes</dt>
<dt>of discovering all unique strings, and which functions are</dt>
<dt>responsible for handling those strings consists of two distinct</dt>
<dt><strong><code>parts</code></strong> :&ensp;<code>find</code> <code>the</code> <code>functions</code>, <code>find</code> <code>the</code> <code>strings</code> <code>within</code> <code>those</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>functions.</p>
<p>For the above process, this function serves only as the moderator.</p>
<p>:param ast: top-level AST generated as a result of parse_file
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def process_ast(self, ast) -&gt; None:
    &#34;&#34;&#34;
    Process an AST by node using custom derived `Visitor`s.

    Properly processing and internalizing an AST for the purposes
    of discovering all unique strings, and which functions are
    responsible for handling those strings consists of two distinct
    parts: find the functions, find the strings within those
    functions.

    For the above process, this function serves only as the moderator.

    :param ast: top-level AST generated as a result of parse_file
    :return: returns nothing
    &#34;&#34;&#34;
    # Unless the file is blank, there will always be a generated
    # AST. Any result otherwise is a critical error
    if sys.getsizeof(ast) &lt; AstParser.MIN_BYTES:
        raise AstEmptyError()

    self.build_function_str_pairs(ast)

    # Opposite of the size check above, finding no strings within an
    # AST is perfectly reasonable, however it can be cause for concern
    if not Record.tpl_list:
        LOGGER.warning(&#34;No strings found in target file&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="astparser..astparser.ConstantVisitor"><code class="flex name class">
<span>class <span class="ident">ConstantVisitor</span></span>
<span>(</span><span><small>ancestors:</small> pycparser.c_ast.NodeVisitor)</span>
</code></dt>
<dd>
<section class="desc"><p>Define the object responsible for locating constants in ASTs.</p>
<p><a title="astparser..astparser.ConstantVisitor" href="#astparser..astparser.ConstantVisitor"><code>ConstantVisitor</code></a> is the example derived <code>NodeVisitor</code> described
in the PycParser documentation at L:109
<a href="https://github.com/eliben/pycparser/blob/master/pycparser/c_ast.py">https://github.com/eliben/pycparser/blob/master/pycparser/c_ast.py</a></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class ConstantVisitor(c_ast.NodeVisitor):
    &#34;&#34;&#34;
    Define the object responsible for locating constants in ASTs.

    `ConstantVisitor` is the example derived `NodeVisitor` described
    in the PycParser documentation at L:109
    https://github.com/eliben/pycparser/blob/master/pycparser/c_ast.py
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;
        Initialize the `ConstantVisitor` object.

        :return: returns nothing
        &#34;&#34;&#34;
        self.values = []

    def visit_Constant(self, node) -&gt; None:
        &#34;&#34;&#34;
        Create a list of values of the constant nodes encountered.

        Does not traverse the children of nodes for which this function
        was defined. To do that, call the base `NodeVisitor` member
        function generic_visit() on the target node.

        :param node: AST `FuncDef` node
        :return: returns nothing
        &#34;&#34;&#34;
        try:
            # Ints are not captured as unique identifiers in IDA-CFP
            # and thus must be removed from the list of potential
            # unique constants
            int(node.value)

        except ValueError:
            # When strings are found by traversal they are wrapped in an
            # extra set of double quotes.
            stripped = node.value.replace(&#39;&#34;&#39;, &#39;&#39;)
            if stripped:
                self.values.append(stripped)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="astparser..astparser.ConstantVisitor.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Initialize the <a title="astparser..astparser.ConstantVisitor" href="#astparser..astparser.ConstantVisitor"><code>ConstantVisitor</code></a> object.</p>
<p>:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def __init__(self) -&gt; None:
    &#34;&#34;&#34;
    Initialize the `ConstantVisitor` object.

    :return: returns nothing
    &#34;&#34;&#34;
    self.values = []</code></pre>
</details>
</dd>
<dt id="astparser..astparser.ConstantVisitor.visit_Constant"><code class="name flex">
<span>def <span class="ident">visit_Constant</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a list of values of the constant nodes encountered.</p>
<p>Does not traverse the children of nodes for which this function
was defined. To do that, call the base <code>NodeVisitor</code> member
function generic_visit() on the target node.</p>
<p>:param node: AST <code>FuncDef</code> node
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def visit_Constant(self, node) -&gt; None:
    &#34;&#34;&#34;
    Create a list of values of the constant nodes encountered.

    Does not traverse the children of nodes for which this function
    was defined. To do that, call the base `NodeVisitor` member
    function generic_visit() on the target node.

    :param node: AST `FuncDef` node
    :return: returns nothing
    &#34;&#34;&#34;
    try:
        # Ints are not captured as unique identifiers in IDA-CFP
        # and thus must be removed from the list of potential
        # unique constants
        int(node.value)

    except ValueError:
        # When strings are found by traversal they are wrapped in an
        # extra set of double quotes.
        stripped = node.value.replace(&#39;&#34;&#39;, &#39;&#39;)
        if stripped:
            self.values.append(stripped)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="astparser..astparser.FuncDefVisitor"><code class="flex name class">
<span>class <span class="ident">FuncDefVisitor</span></span>
<span>(</span><span><small>ancestors:</small> pycparser.c_ast.NodeVisitor)</span>
</code></dt>
<dd>
<section class="desc"><p>Define the object responsible for locating function definitions in ASTs.</p>
<p><a title="astparser..astparser.FuncDefVisitor" href="#astparser..astparser.FuncDefVisitor"><code>FuncDefVisitor</code></a> is the example derived <code>NodeVisitor</code> described
in the PycParser documentation at L:25
<a href="https://github.com/eliben/pycparser/blob/master/examples/func_defs.py">https://github.com/eliben/pycparser/blob/master/examples/func_defs.py</a></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class FuncDefVisitor(c_ast.NodeVisitor):
    &#34;&#34;&#34;
    Define the object responsible for locating function definitions in ASTs.

    `FuncDefVisitor` is the example derived `NodeVisitor` described
    in the PycParser documentation at L:25
    https://github.com/eliben/pycparser/blob/master/examples/func_defs.py
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;
        Initialize the `FuncDefVisitor` object.

        :return: returns nothing
        &#34;&#34;&#34;
        self.nodes = []

    def visit_FuncDef(self, node) -&gt; None:
        &#34;&#34;&#34;
        Create a list of `FuncDef` nodes encountered.

        Does not traverse the children of nodes for which this function
        was defined. To do that, call the base `NodeVisitor` member
        function generic_visit() on the target node.

        :param node: top-level AST generated as a result of parse_file
        :return: returns nothing
        &#34;&#34;&#34;
        self.nodes.append(node)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="astparser..astparser.FuncDefVisitor.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Initialize the <a title="astparser..astparser.FuncDefVisitor" href="#astparser..astparser.FuncDefVisitor"><code>FuncDefVisitor</code></a> object.</p>
<p>:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def __init__(self) -&gt; None:
    &#34;&#34;&#34;
    Initialize the `FuncDefVisitor` object.

    :return: returns nothing
    &#34;&#34;&#34;
    self.nodes = []</code></pre>
</details>
</dd>
<dt id="astparser..astparser.FuncDefVisitor.visit_FuncDef"><code class="name flex">
<span>def <span class="ident">visit_FuncDef</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a list of <code>FuncDef</code> nodes encountered.</p>
<p>Does not traverse the children of nodes for which this function
was defined. To do that, call the base <code>NodeVisitor</code> member
function generic_visit() on the target node.</p>
<p>:param node: top-level AST generated as a result of parse_file
:return: returns nothing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def visit_FuncDef(self, node) -&gt; None:
    &#34;&#34;&#34;
    Create a list of `FuncDef` nodes encountered.

    Does not traverse the children of nodes for which this function
    was defined. To do that, call the base `NodeVisitor` member
    function generic_visit() on the target node.

    :param node: top-level AST generated as a result of parse_file
    :return: returns nothing
    &#34;&#34;&#34;
    self.nodes.append(node)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="astparser." href="index.html">astparser.</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="astparser..astparser.AstParser" href="#astparser..astparser.AstParser">AstParser</a></code></h4>
<ul class="">
<li><code><a title="astparser..astparser.AstParser.MIN_BYTES" href="#astparser..astparser.AstParser.MIN_BYTES">MIN_BYTES</a></code></li>
<li><code><a title="astparser..astparser.AstParser.__init__" href="#astparser..astparser.AstParser.__init__">__init__</a></code></li>
<li><code><a title="astparser..astparser.AstParser.build_function_str_pairs" href="#astparser..astparser.AstParser.build_function_str_pairs">build_function_str_pairs</a></code></li>
<li><code><a title="astparser..astparser.AstParser.locate_func_strings" href="#astparser..astparser.AstParser.locate_func_strings">locate_func_strings</a></code></li>
<li><code><a title="astparser..astparser.AstParser.locate_functions" href="#astparser..astparser.AstParser.locate_functions">locate_functions</a></code></li>
<li><code><a title="astparser..astparser.AstParser.process_ast" href="#astparser..astparser.AstParser.process_ast">process_ast</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="astparser..astparser.ConstantVisitor" href="#astparser..astparser.ConstantVisitor">ConstantVisitor</a></code></h4>
<ul class="">
<li><code><a title="astparser..astparser.ConstantVisitor.__init__" href="#astparser..astparser.ConstantVisitor.__init__">__init__</a></code></li>
<li><code><a title="astparser..astparser.ConstantVisitor.visit_Constant" href="#astparser..astparser.ConstantVisitor.visit_Constant">visit_Constant</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="astparser..astparser.FuncDefVisitor" href="#astparser..astparser.FuncDefVisitor">FuncDefVisitor</a></code></h4>
<ul class="">
<li><code><a title="astparser..astparser.FuncDefVisitor.__init__" href="#astparser..astparser.FuncDefVisitor.__init__">__init__</a></code></li>
<li><code><a title="astparser..astparser.FuncDefVisitor.visit_FuncDef" href="#astparser..astparser.FuncDefVisitor.visit_FuncDef">visit_FuncDef</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.5.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>